name: Publish and inventory

on:
  workflow_dispatch: {}
  schedule:
    - cron: '*/60 * * * *'   # every 60 minutes

permissions:
  contents: write

jobs:
  snapshot-and-inventory:
    runs-on: ubuntu-latest
    env:
      ROOT: Explorer
      OUT_CSV: docs/ProjectInventory.csv
      GH_PAT: ${{ secrets.GH_PAT }}

    steps:
      - name: Checkout repo (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Ensure docs folder exists
        run: mkdir -p docs

      - name: Capture repository identity & source commit (to pin raw URLs)
        run: |
          echo "REPO_FULL=$GITHUB_REPOSITORY" >> "$GITHUB_ENV"
          echo "COMMIT_SHA=$(git rev-parse HEAD)" >> "$GITHUB_ENV"

      - name: Setup Python 3
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Generate docs/ProjectInventory.csv (raw_repo_url + wc-style line_count)
        env:
          ROOT: ${{ env.ROOT }}
          OUT_CSV: ${{ env.OUT_CSV }}
          REPO_FULL: ${{ env.REPO_FULL }}
          COMMIT_SHA: ${{ env.COMMIT_SHA }}
        run: |
          python3 - <<'PY'
          import os, csv, sys

          ROOT = os.environ.get("ROOT", "Explorer")
          OUT_CSV = os.environ.get("OUT_CSV", "docs/ProjectInventory.csv")
          REPO_FULL = os.environ.get("REPO_FULL", "")
          COMMIT_SHA = os.environ.get("COMMIT_SHA", "")

          if "/" not in REPO_FULL or not COMMIT_SHA:
              print("Missing REPO_FULL/COMMIT_SHA", file=sys.stderr)
              sys.exit(2)

          owner, repo = REPO_FULL.split("/", 1)
          base = os.getcwd()

          inventory = []
          if os.path.isdir(ROOT):
              for dirpath, dirnames, filenames in os.walk(ROOT):
                  filenames.sort()
                  for fn in filenames:
                      if not fn.lower().endswith(".luau"):
                          continue
                      full_path = os.path.join(dirpath, fn)
                      rel = os.path.relpath(full_path, base).replace("\\", "/")
                      with open(full_path, "rb") as fh:
                          raw = fh.read()
                      # wc -l semantics: count '\n' bytes
                      line_count = raw.count(b"\n")
                      byte_size = len(raw)
                      raw_url = f"https://raw.githubusercontent.com/{owner}/{repo}/{COMMIT_SHA}/{rel}"
                      inventory.append((os.path.basename(rel), rel, raw_url, COMMIT_SHA, line_count, byte_size))

          os.makedirs(os.path.dirname(OUT_CSV), exist_ok=True)
          with open(OUT_CSV, "w", newline="", encoding="utf-8") as f:
              w = csv.writer(f)
              w.writerow(["filename","repo_path","raw_repo_url","commit_sha","line_count","byte_size"])
              for row in inventory:
                  w.writerow(row)

          print(f"Wrote inventory to {OUT_CSV} with {len(inventory)} entries (pinned {COMMIT_SHA}).")
          PY

      - name: Commit & push ProjectInventory.csv (if changed)
        id: commit
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
          OUT_CSV: ${{ env.OUT_CSV }}
        run: |
          set -euo pipefail

          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          git add "${OUT_CSV}" || true

          if git diff --staged --quiet; then
            echo "No changes to commit."
            echo "changed=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          git commit -m "chore: regenerate ProjectInventory.csv (auto)"

          # Auth & push logic (safe push to main; else PR)
          remote_url="https://x-access-token:${GH_PAT}@github.com/${GITHUB_REPOSITORY}.git"
          git remote set-url origin "$remote_url"

          git fetch origin main
          LOCAL=$(git rev-parse @)
          REMOTE=$(git rev-parse origin/main)
          BASE=$(git merge-base @ origin/main)

          if [ "$REMOTE" = "$BASE" ]; then
            echo "Remote origin/main is ancestor â€” pushing directly."
            git push origin HEAD:main
            echo "pushed_direct=true" >> "$GITHUB_OUTPUT"
            echo "changed=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Remote advanced; pushing to a branch and opening PR."
          pr_branch="projectinventory/update-${GITHUB_RUN_ID}"
          git push origin HEAD:"${pr_branch}" --force-with-lease
          echo "pr_branch=${pr_branch}" >> "$GITHUB_OUTPUT"
          echo "changed=true" >> "$GITHUB_OUTPUT"

      - name: Create Pull Request if we pushed a branch
        if: ${{ steps.commit.outputs.pr_branch != '' }}
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GH_PAT }}
          commit-message: "chore: regenerate ProjectInventory.csv"
          title: "chore: regenerate ProjectInventory.csv"
          body: |
            Auto-generated update of ProjectInventory.csv.
            Raw URLs are pinned to the source commit used during generation.
          base: main
          head: ${{ steps.commit.outputs.pr_branch }}
          labels: auto-generated
          draft: false

