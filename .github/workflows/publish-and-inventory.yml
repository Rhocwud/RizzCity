name: Publish and inventory

on:
  workflow_dispatch: {}
  schedule:
    - cron: '*/60 * * * *'   # every 60 minutes

permissions:
  contents: write

jobs:
  snapshot-and-inventory:
    runs-on: ubuntu-latest
    env:
      ROOT: Explorer
      OUT_CSV: docs/ProjectInventory.csv
      GH_PAT: ${{ secrets.GH_PAT }}

    steps:
      - name: Checkout repo (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Record source commit SHA (pin URLs to this)
        run: |
          echo "SOURCE_SHA=$(git rev-parse HEAD)" >> "$GITHUB_ENV"

      - name: Ensure docs folder exists
        run: mkdir -p docs

      - name: Setup Python 3
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Generate docs/ProjectInventory.csv (pinned raw URLs + wc-style line_count)
        env:
          ROOT: ${{ env.ROOT }}
          OUT_CSV: ${{ env.OUT_CSV }}
          SOURCE_SHA: ${{ env.SOURCE_SHA }}
          REPO_SLUG: ${{ github.repository }}   # <owner>/<repo>
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import csv, os, sys

          ROOT        = os.environ.get("ROOT", "Explorer")
          OUT_CSV     = os.environ.get("OUT_CSV", "docs/ProjectInventory.csv")
          SOURCE_SHA  = os.environ.get("SOURCE_SHA") or ""
          REPO_SLUG   = os.environ.get("REPO_SLUG")  or ""

          if not SOURCE_SHA or not REPO_SLUG:
              print("Missing SOURCE_SHA or REPO_SLUG env.", file=sys.stderr)
              sys.exit(2)

          repo_root = os.getcwd()
          rows = []

          # Collect .luau files deterministically
          if os.path.isdir(ROOT):
              for dirpath, dirnames, filenames in os.walk(ROOT):
                  dirnames.sort()
                  for fn in sorted(filenames):
                      if not fn.lower().endswith(".luau"):
                          continue
                      full = os.path.join(dirpath, fn)
                      rel  = os.path.relpath(full, repo_root).replace("\\", "/")

                      with open(full, "rb") as fh:
                          raw = fh.read()

                      # wc -l semantics: count of '\n'
                      line_count = raw.count(b"\n")
                      byte_size  = len(raw)

                      raw_url = f"https://raw.githubusercontent.com/{REPO_SLUG}/{SOURCE_SHA}/{rel}"

                      rows.append({
                          "filename":   os.path.basename(rel),
                          "repo_path":  rel,
                          "raw_repo_url": raw_url,
                          "commit_sha": SOURCE_SHA,
                          "line_count": line_count,
                          "byte_size":  byte_size,
                      })

          # Ensure docs folder exists
          os.makedirs(os.path.dirname(OUT_CSV), exist_ok=True)

          # Write CSV
          with open(OUT_CSV, "w", newline="", encoding="utf-8") as f:
              w = csv.writer(f)
              w.writerow(["filename","repo_path","raw_repo_url","commit_sha","line_count","byte_size"])
              for r in rows:
                  w.writerow([r["filename"], r["repo_path"], r["raw_repo_url"], r["commit_sha"], r["line_count"], r["byte_size"]])

          print(f"Wrote {OUT_CSV} with {len(rows)} entries at commit {SOURCE_SHA}")
          PY

      - name: Commit & push ProjectInventory.csv (if changed)
        id: commit
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
          OUT_CSV: ${{ env.OUT_CSV }}
        run: |
          set -euo pipefail

          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          git add "${OUT_CSV}" || true

          # If there are no staged changes, exit cleanly and mark changed=false
          if git diff --staged --quiet; then
            echo "No changes to commit."
            echo "changed=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          git commit -m "chore: regenerate ProjectInventory.csv (pinned raw URLs + line_count)"

          # Prepare auth for pushing
          remote_url="https://x-access-token:${GH_PAT}@github.com/${GITHUB_REPOSITORY}.git"
          git remote set-url origin "$remote_url"

          # Fetch current remote main
          git fetch origin main

          LOCAL=$(git rev-parse @)
          REMOTE=$(git rev-parse origin/main)
          BASE=$(git merge-base @ origin/main)

          if [ "$REMOTE" = "$BASE" ]; then
            echo "Remote origin/main is ancestor — pushing directly."
            git push origin HEAD:main
            echo "pushed_direct=true" >> "$GITHUB_OUTPUT"
            echo "changed=true" >> "$GITHUB_OUTPUT"
            echo "pr_branch=" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "origin/main changed — pushing to a branch and opening PR."
          pr_branch="projectinventory/update-${GITHUB_RUN_ID}"
          git push origin HEAD:"${pr_branch}" --force-with-lease
          echo "pr_branch=${pr_branch}" >> "$GITHUB_OUTPUT"
          echo "changed=true" >> "$GITHUB_OUTPUT"

      - name: Create Pull Request if we pushed a branch
        if: ${{ steps.commit.outputs.pr_branch != '' }}
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GH_PAT }}
          commit-message: "chore: regenerate ProjectInventory.csv (pinned raw URLs + line_count)"
          title: "chore: regenerate ProjectInventory.csv (pinned raw URLs + line_count)"
          body: |
            Auto-generated update of ProjectInventory.csv.
            - Only CSV is produced (no gist, no mapping txt).
            - raw_repo_url is pinned to SOURCE_SHA.
            - line_count is wc-style to catch newline issues immediately.
          base: main
          head: ${{ steps.commit.outputs.pr_branch }}
          labels: auto-generated
          draft: false
