name: Publish and inventory

on:
  workflow_dispatch: {}          # manual run
  schedule:                      # scheduled run every 30 minutes
    - cron: '*/30 * * * *'

permissions:
  contents: write

jobs:
  snapshot-and-inventory:
    runs-on: ubuntu-latest
    env:
      ROOT: Explorer
      OUT_CSV: docs/ProjectInventory.csv
      GIST_DESCRIPTION: "RizzCity .luau snapshot (private gist)"
      GH_PAT: ${{ secrets.GH_PAT }}
    steps:
      - name: Checkout repo (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Ensure docs folder exists
        run: mkdir -p docs

      - name: Setup Python 3
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Install Python requirements
        run: python3 -m pip install --user requests

      - name: Create gist snapshot and ProjectInventory.csv
        env:
          ROOT: ${{ env.ROOT }}
          OUT_CSV: ${{ env.OUT_CSV }}
          GIST_DESCRIPTION: ${{ env.GIST_DESCRIPTION }}
          GH_PAT: ${{ env.GH_PAT }}
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import os, json, requests, csv, pathlib, sys
          repo_root = os.getcwd()
          root = os.environ.get("ROOT", "Explorer")
          out_csv = os.environ.get("OUT_CSV", "docs/ProjectInventory.csv")
          gh_pat = os.environ.get("GH_PAT")
          gist_description = os.environ.get("GIST_DESCRIPTION", "luau snapshot")

          if not gh_pat:
              print("ERROR: GH_PAT not set")
              sys.exit(1)

          # Collect files
          files = []
          for dirpath, dirnames, filenames in os.walk(root):
              for fn in sorted(filenames):
                  if fn.lower().endswith(".luau"):
                      full = os.path.join(dirpath, fn)
                      rel = os.path.relpath(full, repo_root).replace("\\", "/")
                      files.append((full, rel))

          if not files:
              print("No .luau files found under", root)
              # Write empty CSV if not exists
              pathlib.Path(os.path.dirname(out_csv)).mkdir(parents=True, exist_ok=True)
              with open(out_csv, "w", newline='', encoding="utf-8") as f:
                  w = csv.writer(f)
                  w.writerow(["filename","repo_path","gist_filename","raw_gist_url","line_count","byte_size"])
              print("Wrote empty", out_csv)
              sys.exit(0)

          # Normalize newlines and prepare gist payload
          gist_files = {}
          inventory_rows = []
          for full, rel in files:
              with open(full, "rb") as f:
                  raw = f.read()
              try:
                  text = raw.decode("utf-8")
              except Exception:
                  # fallback with replace
                  text = raw.decode("utf-8", errors="replace")
              # normalize newlines to LF
              normalized = text.replace("\r\n", "\n").replace("\r", "\n")
              # write back normalized content if differs
              if normalized != text:
                  with open(full, "w", newline="\n", encoding="utf-8") as f:
                      f.write(normalized)
                  print(f"Normalized newlines: {rel}")
              # compute metadata
              lines = len(normalized.splitlines())
              bsize = len(normalized.encode("utf-8"))
              # gist filename: replace '/' with '__' to keep unique flat names
              gist_name = rel.replace("/", "__")
              gist_files[gist_name] = {"content": normalized}
              inventory_rows.append({
                  "filename": os.path.basename(rel),
                  "repo_path": rel,
                  "gist_filename": gist_name,
                  "raw_gist_url": "",   # fill after gist creation
                  "line_count": lines,
                  "byte_size": bsize
              })

          # Create private gist with all files
          headers = {
              "Authorization": f"token {gh_pat}",
              "Accept": "application/vnd.github+json"
          }
          payload = {
              "description": gist_description,
              "public": False,
              "files": gist_files
          }
          resp = requests.post("https://api.github.com/gists", headers=headers, data=json.dumps(payload))
          if resp.status_code not in (200,201):
              print("Failed to create gist:", resp.status_code)
              print(resp.text)
              sys.exit(1)
          gist = resp.json()
          # The response contains 'files' mapping with 'raw_url' fields
          gist_files_resp = gist.get("files", {})

          # Build inventory CSV rows with raw URLs
          for row in inventory_rows:
              gf = gist_files_resp.get(row["gist_filename"], {})
              raw_url = gf.get("raw_url", "")
              row["raw_gist_url"] = raw_url

          # Write CSV to OUT_CSV
          out_dir = os.path.dirname(out_csv)
          if out_dir:
              os.makedirs(out_dir, exist_ok=True)
          with open(out_csv, "w", newline='', encoding="utf-8") as f:
              w = csv.writer(f)
              w.writerow(["filename","repo_path","gist_filename","raw_gist_url","line_count","byte_size"])
              for r in inventory_rows:
                  w.writerow([r["filename"], r["repo_path"], r["gist_filename"], r["raw_gist_url"], r["line_count"], r["byte_size"]])

          print(f"Wrote inventory to {out_csv} with {len(inventory_rows)} entries")
          print("Gist URL:", gist.get("html_url"))
          print("Gist ID:", gist.get("id"))
          PY

      - name: Commit and push ProjectInventory.csv (if changed)
        env:
          GH_PAT: ${{ env.GH_PAT }}
          OUT_CSV: ${{ env.OUT_CSV }}
        run: |
          set -euo pipefail
          # Configure git user
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add "$OUT_CSV" || true

          # exit 0 if no changes
          if git diff --staged --quiet; then
            echo "No changes to commit."
            exit 0
          fi

          git commit -m "chore: regenerate ProjectInventory.csv"
          # Use GH_PAT to push (kept in secret). GitHub masks secrets in logs.
          remote="https://x-access-token:${GH_PAT}@github.com/${GITHUB_REPOSITORY}.git"
          git push "$remote" HEAD:main

